#!/usr/bin/env bash
set -euo pipefail

# tcpman_fifo_path_opt.sh
# Usage:
#   ./tcpman_fifo_path_opt.sh host:port[/path] 'msg1' 'msg2' ...
# Example:
#   ./tcpman_fifo_path_opt.sh localhost:4000/test 'c{creds}' 'q{"action":"ping"}'

URL="$1"
shift || true
if [[ -z "$URL" || $# -eq 0 ]]; then
  echo "Usage: $0 host:port[/path] 'msg1' 'msg2' ..." >&2
  exit 1
fi

# --- Extract host, port, optional path ---
HOSTPORT="${URL%%/*}"             # host:port
PATH_PART="${URL#${HOSTPORT}}"    # /path or empty
[[ "$PATH_PART" == "$URL" ]] && PATH_PART=""  # no path
HOST="${HOSTPORT%%:*}"
PORT="${HOSTPORT##*:}"

if [[ -z "$HOST" || -z "$PORT" ]]; then
  echo "Error: invalid host:port" >&2
  exit 1
fi

# --- Config ---
IDLE_SECONDS="${IDLE_TIME:-0.09}"   # idle wait after last byte
CHUNK_SIZE=4096
TMPDIR=$(mktemp -d)
FIFO="$TMPDIR/tcpman.fifo"
trap 'rc=$?; cleanup; exit $rc' INT TERM EXIT

cleanup() {
  if [[ -n "${READER_PID-}" ]]; then
    kill "${READER_PID}" 2>/dev/null || true
    wait "${READER_PID}" 2>/dev/null || true
  fi
  exec 3>&- 2>/dev/null || true
  [[ -p "$FIFO" ]] && rm -f "$FIFO"
  [[ -d "$TMPDIR" ]] && rmdir "$TMPDIR" 2>/dev/null || true
  unset READER_PID
}

# --- Open TCP socket ---
exec 3<>/dev/tcp/"$HOST"/"$PORT" || { echo "Failed to connect to $HOST:$PORT" >&2; exit 1; }

# --- FIFO reader ---
mkfifo "$FIFO"
( cat <&3 >"$FIFO" ) &
READER_PID=$!

# --- Optional path injection for first_char + JSON messages ---
inject_path() {
  local msg="$1"
  local idx="$2"
  # Only inject if PATH_PART exists and msg looks like first_char + JSON {…}
  if [[ -n "$PATH_PART" && "$idx" -gt 1 && "$msg" =~ ^.?\{.*\}$ ]]; then
    local first_char="${msg:0:1}"
    local json_content="${msg:1}"   # includes {…}
    # Only inject if valid JSON and jq exists
    if command -v jq >/dev/null 2>&1 && jq -e . >/dev/null 2>&1 <<<"$json_content"; then
      # merge path only if not present
      json_content=$(jq -c --arg p "/${PATH_PART#/}" 'if has("path") then . else . + {path:$p} end' <<<"$json_content")
      msg="${first_char}${json_content}"
    fi
    # else: leave msg unchanged (raw or invalid JSON)
  fi
  printf '%s' "$msg"
}

# --- Send and wait response ---
send_and_wait_response() {
  local msg="$1"
  local i="$2"
  msg=$(inject_path "$msg" "$i")
  echo ">>> Sending: $msg" >&2
  printf '%s\n' "$msg" >&3

  # --- wait for first byte ---
  local first_char
  if ! IFS= read -r -n 1 first_char <"$FIFO"; then
    echo "<<< Connection closed by remote (no first byte)" >&2
    return 1
  fi
  printf '%s' "$first_char"

  # --- read remaining bytes until idle ---
  local chunk
  while true; do
    if IFS= read -r -n "$CHUNK_SIZE" -t "$IDLE_SECONDS" chunk <"$FIFO"; then
      [[ -n "$chunk" ]] && printf '%s' "$chunk"
    else
      printf '\n'
      break
    fi
  done
}

# --- Main loop ---
i=0
for msg in "$@"; do
  i=$((i+1))
  if ! send_and_wait_response "$msg" "$i"; then
    echo "Stopping due to closed connection." >&2
    break
  fi
done

cleanup

